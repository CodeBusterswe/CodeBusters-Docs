\section{Architettura del prodotto}
\subsection{Descrizione generale}
Il pattern architetturale scelto dal gruppo per lo sviluppo del progetto è il Model-View-ViewModel. Il seguente pattern è tra i più diffusi nello sviluppo delle web application e permette di scrivere codice facilmente mantenibile e riusabile; questo è possibile grazie al disaccoppiamento lasco che sussiste tra logica di presentazione e di business. Inoltre MVVM è risultato il più adatto per essere utilizzato con React, libreria impiegata per lo sviluppo dell’UI e che renderizza le componenti in base al loro stato interno.
\begin{itemize}
\item \textbf{Model}: questa porzione ricopre la logica di business dell’applicazione, ovvero la gestione dei dati di partenza, dimensioni e strutture create dall’utente ed infine le preferenze di visualizzazione dei grafici. Per una corretta separazione logica, il \textit{Model} è stato suddiviso in tre parti: una dedicata ai dati e alle dimensioni (\textit{Model.js}), una seconda per la gestione delle matrici delle distanze (\textit{DistanceMatricesModel.js}) ed un’ultima dedicata alle preferenze dell’utente (\textit{Preferences.js});

\item \textbf{ViewModel}: qui viene effettuato il \glo{binding} tra \textit{View} e \textit{Model} ed è contenuta la loro logica;

\item \textbf{View}: questa porzione gestisce la presentazione tramite una specifica gerarchia di componenti; ciascun componente contiene la logica strettamente legata alla sua visualizzazione e necessaria al mantenimento del proprio stato interno.
\end{itemize}

Il passaggio dei dati dal \textit{Model} alle varie componenti grafiche avviene attraverso l'utilizzo di un \textit{Context React}, al quale viene passato un'istanza del \textit{ViewModel}. L'utilizzo di un \glo{\textit{Context React}} ci permette di accedere al valore corrente del \textit{ViewModel} in qualsiasi porzione della \textit{View}, senza doverlo passare di componente in componente attraverso le \glo{props}. Nella radice dell'applicazione viene infatti creata un'istanza del \textit{ViewModel}, che viene passata ad un \textit{Context.Provider}, che fa da contenitore per tutta la \textit{View}. All'interno di tale contenitore ogni \glo{component} può utilizzare un \glo{hook} per accedere al \textit{Context React} ed utilizzare il valore più recente del \textit{ViewModel}.\\ È stato scelto di utilizzare un \textit{Context React} per il passaggio dei dati in quanto la nostra applicazione é molto profonda e non risultava conveniente passare i dati per molti componenti rischiando, nel peggiore dei casi, di doverli utilizzare nell'ultimo della gerarchia.\\
Per poter far si che una componente della \textit{View} si renderizzi non solo al cambiamento del suo stato interno, ma anche al cambiamento dei dati nel \textit{Model}, abbiato utilizzato la libreria \glo{\textit{Mobx}}. Questa ci permette di implementare l'\textit{observer pattern} non supportato di default da \textit{React}. A tale scopo questa libreria permette di segnare delle classi, o attributi di esse, come "Observable"; e di costruire dei componenti della \textit{View} come "Observer". Questi componenti vengono automaticamente ri-renderizzati al cambiamento di un qualsiasi attributo "Observable".
\subsection{Diagrammi delle classi}
\subsection{Diagrammi dei package}
\subsection{Diagrammi di attività}
\subsection{Diagrammi di sequenza}
\subsection{Design pattern utilizzati}
